# 工具智能选择特性

## 需求背景

当前工具检索逻辑过于简单，只做关键词匹配返回第一个工具，无法让 LLM 判断工具是否真正适用。

## 目标

借鉴 LangGraph 的 `bind_tools` 机制，让 LLM 看到可用工具列表，自主决定：
1. 是否有可复用的工具
2. 选择哪个工具
3. 是否需要生成新工具

## 设计方案

### 当前流程

```
search_tool_node:
  keywords 匹配 → 返回第一个工具 → 不管是否真的适用
```

### 改造后流程

```
search_tool_node:
  获取同类别工具列表 → 构建工具描述 → LLM 判断 → 返回匹配结果或标记需生成
```

### 核心改动

#### 修改 `nodes.py` 的 `search_tool_node`

```python
async def search_tool_node(state):
    # 1. 获取同类别工具
    tools = tool_registry.search_by_category(state['task_category'])
    
    if not tools:
        return {"need_generate": True}
    
    # 2. 构建工具列表描述
    tools_desc = "\n".join([
        f"- {t['name']}: {t['description']}"
        for t in tools
    ])
    
    # 3. LLM 判断
    prompt = f"""任务: {state['task_description']}
    
可用工具:
{tools_desc}

判断是否有工具可完成此任务。
返回 JSON: {{"use_existing": bool, "tool_name": "..."}}"""
    
    response = await llm.ainvoke([prompt])
    result = parse_json(response)
    
    # 4. 根据 LLM 判断返回结果
    if result["use_existing"]:
        matched = find_tool_by_name(result["tool_name"])
        return {"matched_tool": matched, "need_generate": False}
    else:
        return {"matched_tool": None, "need_generate": True}
```

## 执行步骤

### 步骤1: 修改 registry.py [已完成]
- [x] 添加 `get_tools_summary` 方法，返回工具名+描述文本

### 步骤2: 修改 nodes.py 的 search_tool_node [已完成]
- [x] 获取同类别工具列表
- [x] 构建工具描述 prompt
- [x] 调用 LLM 判断
- [x] 解析 LLM 返回结果

### 步骤3: 测试验证
- [ ] 测试有可复用工具的场景
- [ ] 测试无可复用工具的场景

## Prompt 设计

```
当前任务: {task_description}

可用工具列表:
- multiply: 计算两数乘积
- add: 计算两数之和
- get_current_time: 获取当前时间

请判断:
1. 上述工具中是否有可以完成当前任务的？
2. 如果有，选择最合适的工具名称
3. 如果没有合适的工具，返回需要生成新工具

返回 JSON 格式:
{
    "use_existing": true或false,
    "tool_name": "选中的工具名，无则留空",
    "reason": "选择理由"
}
```

## 预期效果

**场景**: 任务"计算 3 × 15"，已有工具 `multiply`

**之前**: 关键词匹配，可能返回错误的工具或生成新工具

**之后**: LLM 看到 `multiply: 计算两数乘积`，判断可复用，返回该工具
