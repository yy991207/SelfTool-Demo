# 多任务规划特性 - 执行文档

## 1. 需求背景

### 当前问题
用户请求: "首先查询现在时间然后计算678乘以8776的结果"

| 问题 | 说明 |
|------|------|
| 单任务处理 | 系统只生成了获取时间的工具 |
| 任务遗漏 | 计算任务由润色节点 LLM 自行补充，不可靠 |
| 无任务拆分 | 复合请求无法拆解为多个子任务 |

### 目标
支持多任务请求，自动拆分并依次执行多个工具。

---

## 2. 设计方案

### 2.1 新增节点

| 节点 | 功能 |
|------|------|
| `plan_tasks` | 任务规划：将复合请求拆分为子任务列表 |

### 2.2 状态扩展

```python
class SelfToolState(TypedDict):
    # 新增字段
    task_list: List[dict]         # 子任务列表
    current_task_index: int       # 当前执行的任务索引
    task_results: List[dict]      # 各任务执行结果
```

### 2.3 图结构变更

**变更前:**
```
START → analyze → search → generate → ... → format_response → END
```

**变更后:**
```
START → analyze ─[不需要工具]─→ END
              │
              └─[需要工具]─→ plan_tasks → [循环执行每个任务]
                                  │
                                  ↓
                            ┌─────────────────┐
                            │  task_executor  │ ←──┐
                            │  (执行单个任务)  │     │
                            └────────┬────────┘     │
                                     │              │
                              [还有下一个任务?]      │
                                     │              │
                              yes────┴────no        │
                               │           │        │
                               └───────────┼────────┘
                                           ↓
                                   aggregate_results
                                           │
                                           ↓
                                   format_response
                                           │
                                           ↓
                                          END
```

---

## 3. 实现细节

### 3.1 plan_tasks_node

```python
async def plan_tasks_node(state: SelfToolState) -> dict:
    """任务规划节点: 将复合请求拆分为子任务"""
    
    prompt = f"""分析用户请求，拆分为独立的可执行子任务。

用户请求: {state['user_request']}

规则:
1. 每个子任务应该是独立的、可单独执行的
2. 保持任务的执行顺序
3. 如果只有一个任务，也返回包含一个元素的列表

返回 JSON:
{{
    "tasks": [
        {{"id": 1, "description": "任务描述", "category": "datetime|math|text|other"}},
        {{"id": 2, "description": "任务描述", "category": "datetime|math|text|other"}}
    ]
}}
"""
    # 调用 LLM 拆分任务
    response = await llm.ainvoke([HumanMessage(content=prompt)])
    tasks = _extract_json(response.content).get("tasks", [])
    
    return {
        "task_list": tasks,
        "current_task_index": 0,
        "task_results": [],
    }
```

### 3.2 task_executor_node

复用现有流程 (search → generate → safety_check → execute → register)，但针对单个任务执行。

### 3.3 aggregate_results_node

```python
def aggregate_results_node(state: SelfToolState) -> dict:
    """汇总所有任务结果"""
    
    results = state["task_results"]
    combined = "\n".join([
        f"任务{r['task_id']}: {r['result']}" 
        for r in results
    ])
    
    return {
        "execution_result": combined,
    }
```

### 3.4 路由逻辑

```python
def route_after_task_execute(state: SelfToolState) -> str:
    """任务执行后路由"""
    current = state["current_task_index"]
    total = len(state["task_list"])
    
    if current < total - 1:
        return "next_task"  # 还有下一个任务
    return "aggregate"      # 所有任务完成
```

---

## 4. 执行计划

| 步骤 | 任务 | 预计耗时 |
|------|------|----------|
| 1 | 扩展 `state.py` 添加新字段 | 5分钟 |
| 2 | 实现 `plan_tasks_node` | 10分钟 |
| 3 | 实现 `aggregate_results_node` | 5分钟 |
| 4 | 修改 `graph.py` 添加循环结构 | 15分钟 |
| 5 | 添加路由逻辑 | 5分钟 |
| 6 | 测试多任务请求 | 10分钟 |

**总计: 约50分钟**

---

## 5. 测试用例

### 用例1: 单任务
```
输入: "现在几点了"
期望: 拆分为1个任务，正常执行
```

### 用例2: 双任务
```
输入: "首先查询现在时间然后计算678乘以8776"
期望: 
- 拆分为2个任务
- 依次执行: 获取时间 → 计算乘法
- 汇总结果后润色输出
```

### 用例3: 多任务
```
输入: "告诉我现在时间、生成一个随机数、计算123加456"
期望: 拆分为3个任务，依次执行
```

---

## 6. 注意事项

1. **循环控制**: LangGraph 支持条件边实现循环，需要正确设置终止条件
2. **状态累积**: 每次任务执行后更新 `task_results`
3. **错误处理**: 单个任务失败不影响其他任务
4. **性能考虑**: 多任务会增加 LLM 调用次数
